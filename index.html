
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>ByL的小窝</title>
        <meta name="author" content="ByL" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="/js/lib/home.js"></script>

<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div id="desktop-menu">
        <a class="title" href="/">
            <span>BYL的小窝</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;BYL的小窝</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </div>
</nav>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <transition name="into">
                <div id="main" v-show="!loading">
                    <div id="home-head">
    <div id="home-background" ref="homeBackground" data-images="/images/background.jpg"></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>ByL的小窝</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div id="home-posts-wrap"  ref="homePostsWrap">
    <div id="home-posts">
        

<div class="post">
    <a href="/p/7e955098.html">
        <h2 class="post-title">关于java类的一些笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/5/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <span id="more"></span>
<h1>String</h1>
<blockquote>
<p>[!tip]</p>
<ol>
<li>String 对象用于保存字符串, 也就是一组字符序列</li>
<li>字符串常量对象是双引导括起的字符序列</li>
<li>字符串的字符使用unicode字符编码, 一个字符占两个字节 (<mark style="background: #ADCCFFA6;">字母和数字都占两个字节</mark>)</li>
<li>String类较常用的构造方法</li>
</ol>
</blockquote>
<pre><code class="language-java">String s1 = new String();
String s2 = new String(String original);
String s3 = new String(char[] a);
String s4 = new String(char[] a,int startIndex,int count);
</code></pre>
<p>String对象实现了 <code>Serializable</code> 接口, 说明String可以串行化, <mark style="background: #ADCCFFA6;">可以在网络传输</mark></p>
<ul>
<li>String是一个 [[final]] 类, 不可以被其他继承</li>
<li><code>value[]</code> 属性: <code>private final char value[]</code> 字符常量数组,赋值后不可修改 ,但数组[i] 的值可以修改</li>
</ul>
<h1>创建</h1>
<ul>
<li>String s = “hsp”;</li>
<li>String s2 = new String(“hsp”);</li>
</ul>
<h2 id="两者区别">两者区别</h2>
<ol>
<li>方式一: 先从常量池查看是否有 hsp 数据空间, 如果有, 直接指向; 如果没有则重新创建, 然后指向. <mark style="background: #FF5582A6;">s最终指向常量池的空间地址.</mark></li>
<li>方式二: 先在堆中创建空间, 里面维护了value属性, 指向常量池的 hsp 空间. 如果没有 hsp , 重新创建, 如果有, 直接通过value指向, 最终<mark style="background: #FF5582A6;">指向的是堆中的空间地址. </mark></li>
</ol>
<h2 id="特性">特性</h2>
<ol>
<li>String是一个final类, 代表不可变的字符序列</li>
<li>字符串是不可变的. 一个字符串对象一旦被分配, 其内容是不可变的.</li>
</ol>
<pre><code class="language-java">String s3 = &quot;hello&quot;;  
s3 = &quot;haha&quot;;  
// 创建了两个对象, s3 重新指向haha, 而不是改变 &quot;hello&quot;的值  
String s4 = &quot;hello&quot; + &quot;abc&quot;;  
/*创建了1个对象  
* 编译器会优化 等价于 String a = &quot;Helloabc&quot;;* 
* */String a = &quot;hello&quot;;  
String b = &quot;abc&quot;;  
String c = a + b;  
/*创建了三个对象  
* 1. 先创建一个 StringBuilder sb = StringBuilder* 2. 执行 sb.append(&quot;hello&quot;);* 3. 再执行 sb.append(&quot;abc&quot;);* 4. 再调用 sb.toString()方法, 返回一个 new String(value,0,count)对象  
* 最后其实是c -&gt; 堆中的对象(String) value[] -&gt; 池中的 &quot;helloabc&quot;* */
</code></pre>
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>equals</td>
<td>区分大小写,判断内容是否相等</td>
</tr>
<tr>
<td>equalsgnoreCase</td>
<td>忽略大小写的判断内容是否相等</td>
</tr>
<tr>
<td>length</td>
<td>获取字符的个数, 字符串的长度</td>
</tr>
<tr>
<td>indexOf</td>
<td>获取字符串在字符串中第一个出现的索引, 索引从0开始</td>
</tr>
<tr>
<td>lastIndexOf</td>
<td>获取字符串最后一次出现的索引, 索引从0开始</td>
</tr>
<tr>
<td>substring</td>
<td>截取指定范围的子串</td>
</tr>
<tr>
<td>trim</td>
<td>去空格</td>
</tr>
<tr>
<td>charAt</td>
<td>获取某索引处的字符, 注意不能使用Str[index]</td>
</tr>
</tbody>
</table>
<h1>StringBuffer</h1>
<blockquote>
<p>可变字符序列, 可以对字符串内容进行增删<br>
是一个容器<br>
仍然是[[final]]类型<br>
与[[String]]有很多相似的方法</p>
</blockquote>
<h2 id="解析">解析</h2>
<ol>
<li>StringBuffer 的直接父类 是 AbstractStringBuilder</li>
<li>实现了 Serializable, 可以串行化</li>
<li><mark style="background: #FF5582A6;">在AbstractStringBuilder 中, 有属性 char[] value, 不是fnal类型</mark>
<ol>
<li>该数组存放字符串内容, <mark style="background: #FF5582A6;">存放在堆中, 不在常量池内</mark></li>
</ol>
</li>
</ol>
<h2 id="String-vs-StringBuffer">String vs StringBuffer</h2>
<ol>
<li>String 保存的是字符串常量, 里面的值不能更改, 每次String类的更新实际上就是更改地址, 效率较低</li>
<li>StringBuffer保存的是字符串变量, 里面的值可以更改, 不用每次更新地址,效率高</li>
</ol>
<hr>
<h1>StringBuilder</h1>
<ol>
<li>一个可变的字符序列. 此类提供一个与StringBuffer 兼容的API, 但不保真同步(String)Builder不是线程安全. 该类被设计用作StringBuffer的一个简易替换, <mark style="background: #FF5582A6;">用在字符串缓存区被单个线程使用的时候.</mark> 如果可能建议优先采用该类,在大多数实现中, 它比StringBuffer要快</li>
<li>在StringBuilder上主要操作是 append 和 insert方法, 可重载这些方法,以接受任意类型的数据</li>
</ol>
<h2 id="String-StringBuffer-StringBuilder-比较">[[String]] [[StringBuffer]] [[StringBuilder]] 比较</h2>
<ol>
<li>结构非常相似,均代表可变的字符序列, 而且方法也一样</li>
<li>String: 不可变字符序列, 效率低, 但复用率高
<ol>
<li>StringBuffer: 可变字符序列, 效率较高(增删) 线程安全</li>
<li>StringBuilder: 可变字符序列 效率最高 线程不安全</li>
</ol>
</li>
</ol>
<hr>
<h1>HashSet</h1>
<h2 id="添加元素机制">添加元素机制</h2>
<ol>
<li>HashSet底层是[[HashMap]]</li>
<li>添加一个元素时, 先得到hash值 - 会转化成 -&gt; 索引值</li>
<li>找到存储数据表table, 看这个索引位置是否已存放的有元素</li>
<li>如果没有直接加入</li>
<li>如果有, 调用equals比较,如果相同就放弃添加, 如果不同就添加到最后</li>
<li>在Java8中, 如果一条链表的元素超过TREEIFY_THRESHOLD(默认是8), 并且table的大小 &gt;= MIN_TREEIFY_CAPACITY(默认64)就会进行树化(红黑树)</li>
</ol>
<h2 id="源码解析">源码解析</h2>
<ol>
<li>HashSet</li>
</ol>
<pre><code class="language-java">public HashSet() &#123;  
    map = new HashMap&lt;&gt;();  
&#125;
</code></pre>
<ol start="2">
<li>add()</li>
</ol>
<pre><code class="language-java">public boolean add(E e) &#123;  
    return map.put(e, PRESENT)==null;  
&#125;
</code></pre>
<ol>
<li>put()</li>
</ol>
<pre><code class="language-java">public V put(K key, V value) &#123;  //PRESENT = private static final Object PRESENT = new Object();
    return putVal(hash(key), key, value, false, true);  
&#125;
</code></pre>
<pre><code class="language-java">static final int hash(Object key) &#123;  
    int h;  
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);  
&#125;
</code></pre>
<pre><code>该方法会执行hash(key) , 会的到一个hash值
	与hashcode不同
	&gt; 减少hash冲突概率
</code></pre>
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,  
               boolean evict) &#123;  
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;  
    if ((tab = table) == null || (n = tab.length) == 0)  
        n = (tab = resize()).length;  
    if ((p = tab[i = (n - 1) &amp; hash]) == null)  
        tab[i] = newNode(hash, key, value, null);  
    else &#123;  
        Node&lt;K,V&gt; e; K k;  
        if (p.hash == hash &amp;&amp;  
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))  
            e = p;  
        else if (p instanceof TreeNode)  
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);  
        else &#123;  
            for (int binCount = 0; ; ++binCount) &#123;  
                if ((e = p.next) == null) &#123;  
                    p.next = newNode(hash, key, value, null);  
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  
                        treeifyBin(tab, hash);  
                    break;  
                &#125;  
                if (e.hash == hash &amp;&amp;  
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))  
                    break;  
                p = e;  
            &#125;  
        &#125;  
        if (e != null) &#123; // existing mapping for key  
            V oldValue = e.value;  
            if (!onlyIfAbsent || oldValue == null)  
                e.value = value;  
            afterNodeAccess(e);  
            return oldValue;  
        &#125;  
    &#125;  
    ++modCount;  
    if (++size &gt; threshold)  
        resize();  
    afterNodeInsertion(evict);  
    return null;  
&#125;
</code></pre>
<h1>HashMap</h1>
<blockquote>
<p>HaspMap底层是 数组 + 链表 + 红黑树</p>
</blockquote>
<hr>
<h1>LinkedList</h1>
<blockquote>
<p>[!tip]</p>
<ol>
<li>LinkedList底层实现了双向链表和双端队列特点</li>
<li>可以添加任意元素, 元素可以重复, 包括null</li>
<li>线程不安全, 没有实现同步</li>
</ol>
</blockquote>
<h2 id="底层操作机制">底层操作机制</h2>
<ol>
<li>LinkedList底层维护了一个双向链表</li>
<li>LinkedList中维护了两个属性 first 和 last 分别指向首结点 和 尾结点</li>
<li>每个结点 Node对象, 里面又维护了prev next item 三个属性</li>
<li>prev 指向前一个</li>
<li>next 指向后一个</li>
<li>item 为值</li>
<li>最终实现了双向链表</li>
<li>所以LinkedList的元素的添加和删除,不是通过数组完成的,相对效率较高 (增删)</li>
</ol>
<hr>
<h1>LinkedHashSet</h1>
<blockquote>
<p>[!tip]</p>
<ol>
<li>LinkedHashSet是[[HashSet]]的子类</li>
<li>LinkeHashSet底层是一个LinkedHashMap, 底层维护了一个数组 + 双向链表</li>
<li>LinkedHashSet 根据元素的hashCode 值来决定元素的存储位置, 同时是哟哦那个链表维护元素的次序, 这使得元素看起来是以插入顺序保存的</li>
</ol>
</blockquote>
<hr>
<h1>ArrayList</h1>
<blockquote>
<p>继承了[[List]]</p>
</blockquote>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>permits all elements, including null, ArrayList 可以加入null, 并且多个</li>
<li>ArrayList 时由数组来实现数据存储的</li>
<li>ArrayList基本等同于[[Vector]], 除了ArrayList是线程不安全 (执行效率高)</li>
</ol>
<h2 id="底层源码分析重点难点">底层源码分析<s>重点</s><em>难点</em></h2>
<ol>
<li>ArrayList中维护了一个Object类型的数组 elementData
<ol>
<li><code>transient[^1] Object[] elementData;</code></li>
</ol>
</li>
<li>当创建ArrayList对象时, 如果使用的是无参构造器, 则初始elementData的容量为0, 第一次添加, 则扩容elementData为10, 如果需要再次扩容,则扩容elementData为1.5倍.</li>
<li>如果使用的是指定大小的构造器, 则初始elementData容量为指定大小, 如果需要扩容,则直接扩容elementData为1.5倍</li>
</ol>
<h1>Vector</h1>
<h2 id="底层结构">底层结构</h2>
<blockquote>
<p>属于[[List]]接口</p>
</blockquote>
<ol>
<li>Vector 也属于一个对象数组, <code>protected Object[] elementData</code>;</li>
<li>Vector 是线程同步的, 即线程安全, Vector类的操作方法带有synchronized</li>
<li>在开发中, 需要线程同步安全时, 考虑使用Vector</li>
</ol>
<h2 id="vector和-ArrayList-比较">vector和[[ArrayList]]比较</h2>
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>版本</th>
<th>线程安全,效率</th>
<th>扩容倍数</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>jdk1.2</td>
<td>不安全,效率高</td>
<td>如果有参构造1.5倍,如果无参构造第一次10,第二次1.5倍</td>
</tr>
<tr>
<td>Vector</td>
<td>可变数组</td>
<td>jdk1.0</td>
<td>安全,效率不高</td>
<td>如果无参, 默认10 第二次2倍,指定大小,每次2倍扩容</td>
</tr>
</tbody>
</table>
<hr>
<h1>System</h1>
<h2 id="常用方法">常用方法</h2>
<ol>
<li>exit 退出当前方法</li>
<li>arraycopy 复制数组元素, 比较适合底层调用, 一般使用
<ol>
<li>[[Arrays]].copyOf 完成赋值数组</li>
<li>int[] ser = {1,2,3};</li>
<li>int[] dest = int[3];</li>
<li>System.arraycopy(src,0,dest,0,3);</li>
</ol>
</li>
<li>currentTimeMillens: 返回当前时间距离1970-1-1 的毫秒数</li>
<li>gc: 运行垃圾回收机制 System.gc()</li>
</ol>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E7%AC%94%E8%AE%B0/" style="color: #ffa2c4">笔记</a>
        </span>
        
    </div>
    <a href="/p/7e955098.html" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/p/fd8e9709.html">
        <h2 class="post-title">java学习的一些笔记</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/5/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <span id="more"></span>
<h1>代码块</h1>
<h2 id="基本介绍">基本介绍</h2>
<ul>
<li>属于类中的成员</li>
<li>类似于方法, 将逻辑语句封装在方法体中, 通过{}包围起来
<ul>
<li>不能通过对象或类显式调用, 而是加载类时, 或创建对象时隐式调用</li>
</ul>
</li>
</ul>
<h2 id="基本语法">基本语法</h2>
<pre><code>[修饰符] &#123;
	代码
&#125;;
</code></pre>
<ol>
<li>修饰符只有[[static]]</li>
<li>代码块分为两类静态代码块和普通代码块</li>
<li>逻辑语句可以是任何逻辑语句</li>
<li>;可以写,也可以省略</li>
</ol>
<h2 id="细节">细节</h2>
<ol>
<li><mark style="background: #FF5582A6;">static 代码块,作用就是对类进行初始化, 而且它随着类的加载而执行, 并且只会执行一次</mark>,
<ol>
<li>如果是普通代码块, 没创建一个对象就执行.</li>
</ol>
</li>
<li>类什么时候被加载<br>
1. 创建对象实例时, new<br>
2. <mark style="background: #ABF7F7A6;">创建子类对象实例,父类也会被加载</mark><br>
3. <mark style="background: #ABF7F7A6;">使用类的静态成员时(静态属性, 静态方法)</mark></li>
<li>普通的代码块, 在创建对象实例时, 会被隐式调用.被创建一次就会调用一次.
<ol>
<li><mark style="background: #FF5582A6;">如果只是使用类的静态成员时,普通代码块就不会执行.</mark>
<ol>
<li><mark style="background: #FFF3A3A6;">因为静态方法只能调用静态变量和静态方法,静态代码块</mark></li>
</ol>
</li>
</ol>
</li>
<li>![[类的调用顺序]]</li>
<li>构造方法的最气那面其实隐含了 super() 和普通代码块, 静态相关的代码块, 属性初始化, 在类加载时, 就执行完毕了, 因此有优先于构造器和普通代码块执行的</li>
<li>静态代码块只能直接调用用静态成员, 普通代码块可以调用任意成员
<ol>
<li>[[类的调用顺序]]中, <mark style="background: #ABF7F7A6;">静态初始化时, 普通还未初始化所以不可以调用</mark></li>
</ol>
</li>
</ol>
<hr>
<h1>多态</h1>
<h3 id="对象的多态">对象的多态</h3>
<ol>
<li>一个对象的编译类型和运行类型可以不一致</li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的</li>
<li><mark style="background: #FF5582A6;">编译类型看定义时 = 号的左边，运行类型看 = 号的右边</mark></li>
</ol>
<blockquote>
<p>看运行时执行的运行状态是什么, 则运行哪个方法.</p>
</blockquote>
<h3 id="属性重写问题">属性重写问题</h3>
<ul>
<li>属性没有重写!
<ul>
<li>属性的值看编译类型</li>
</ul>
</li>
</ul>
<pre><code class="language-java">bb instanceof AA
</code></pre>
<p><code>instanceof</code> 比较操作符 : 用于判断对象的类型是否为XX类型或XX类型的字类型</p>
<h2 id="向上转型">向上转型</h2>
<hr>
<ul>
<li>特点
<ul>
<li>可以调用父类的所有成员(需要遵守访问权限)</li>
<li>但是不能调用子类的特有成员
<ul>
<li>因为在编译阶段,能调用哪些成员由编译类型来决定</li>
</ul>
</li>
<li>最终的运行效果看子类的具体实现</li>
</ul>
</li>
</ul>
<h2 id="向下转型">向下转型</h2>
<hr>
<pre><code class="language-java">cat cat = (cat)animal;
</code></pre>
<ul>
<li>特点
<ul>
<li>只能强制转换父类的引用,不能强制转换父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>可以调用子类类型中所有的成员</li>
</ul>
</li>
</ul>
<h1>动态绑定机制</h1>
<hr>
<ol>
<li>当调用对象方法的时候, 该方法会和该对象的内存地址/ 运行类型绑定</li>
<li>当调用对象属性时, 没有动态绑定机制, 哪里声明,哪里使用</li>
</ol>
<hr>
<blockquote>
<p>方法看运行, 属性看编译.</p>
</blockquote>
<hr>
<hr>
<h1>多态数组</h1>
<pre><code class="language-java">public static void main(String[] args) &#123;  
    Person[] persons = new Person[5];  
    persons[0] = new Person();  
    persons[1] = new Student();  
    persons[2] = new Student();  
    persons[3] = new teacher();  
    persons[4] = new Teacher();  
&#125;
</code></pre>
<blockquote>
<p>利用[[多态]]的动态绑定机制建立动态分配运行类型</p>
</blockquote>
<h2 id="多态数组如何调用子类特有的方法">多态数组如何调用子类特有的方法</h2>
<blockquote>
<p><mark style="background: #ADCCFFA6;">向下转型</mark></p>
</blockquote>
<pre><code class="language-java">for (int i = 0; i &lt; 5; i++) &#123;  
    if (persons[i] instanceof Student) &#123;  
        (Student)persons[i].study();  
    &#125; else if (persons[i] instanceof Teacher) &#123;  
        (Teacher)persons[i].teach();  
    &#125;  
&#125;
</code></pre>
<p>通过 <code>instanceof</code> 判断向上转型的对象时候是该子类, 如果是那么将其<strong>向下转型</strong>到用</p>
<h1>接口的多态特性</h1>
<blockquote>
<p>[!ob-example] 接口的[[多态]]特性</p>
<ol>
<li>多态参数</li>
<li>多态数组</li>
<li>接口存在多态传递现象</li>
</ol>
</blockquote>
<pre><code class="language-java">public interface IF &#123;  
&#125;  
  
class Monster implements IF &#123;&#125;  
class Car implements IF &#123;&#125;  
  
class Test &#123;  
    public static void main(String[] args) &#123; 
	    //接口的多态体现
	    //接口类型的变量 if1 可以指向 实现了IF接口的对象实例
	    //向上转型 
        IF if1 = new Monster();  
        if1 = new Car();  
    &#125;  
&#125;
</code></pre>
<h2 id="接口存在多态传递现象">接口存在多态传递现象</h2>
<p>和继承多次向上转型没区别</p>
<h1>类的调用顺序</h1>
<ol>
<li>调用静态代码块和静态属性初始话
<ol>
<li>静态代码块和静态属性初始话调用的优先级一样,</li>
<li>如果有多个静态代码块和静态属性,则按他们定义的顺序调用</li>
</ol>
</li>
<li>调用普通代码块和普通属性的初始化</li>
<li>调用构造方法</li>
</ol>
<h3 id="继承后的调用顺序">继承后的调用顺序</h3>
<ol>
<li>父类的静态</li>
<li>子类的静态</li>
<li>父类的普通代码块和普通属性初始化</li>
<li>父类的构造方法</li>
<li>子类的普通[[代码块]]和普通属性初始化</li>
<li>子类的构造方法</li>
</ol>
<hr>
<blockquote>
<p>也就是说先在堆内存中初始化静态域, 然后在初始化普通域</p>
</blockquote>
<h1>元注解</h1>
<blockquote>
<p>元注解就是修饰注解的注解</p>
</blockquote>
<blockquote>
<p>[!emample] 元注解</p>
<ol>
<li><code>Retention</code> 指定注解的作用范围,</li>
<li>source</li>
<li>class</li>
<li>runtime</li>
<li><code>target</code> 指定注解可以在哪些地方使用</li>
<li><code>Documented</code> 指定该注解是否会在javadoc 体现</li>
<li><code>Inherited</code> 子类会继承父类注解</li>
</ol>
</blockquote>
<h1>注解</h1>
<blockquote>
<p>[!Annotation]<br>
用于修饰解释 包 类 方法 属性 构造器 局部变量等信息</p>
<ul>
<li>也称为元数据</li>
</ul>
</blockquote>
<ol>
<li>和注释一样, 注解不影响程序的逻辑, 但注解可以被编译或运行, 相当于嵌入在代码中的补充信息</li>
<li>在javaSE中, 注解的使用目的比较简单, 标记过时的功能, 忽略警告</li>
<li>在javaEE中注解占据了重要的角色, 例如用来配置应用程序的任何切面, 代替Java EE 旧版中所遗留的冗余代码和XML配置等</li>
</ol>
<p>[^3]&gt;[!example] 基本注解</p>
<blockquote>
<ol>
<li><code>@Override</code> 限定某个方法, 是重写父类的方法, 该注解只能用于方法</li>
<li><code>@Deprecated</code> 用于表示某个程序元素(类 方法) 已经过时</li>
<li><code>@SuppressWarning</code> 抑制编译器警告</li>
</ol>
</blockquote>
<h3 id="Override">Override</h3>
<ol>
<li><code>Override</code> 表示指定重写父类的方法</li>
<li>只能修饰方法</li>
<li><code>@Target</code> 是修饰注解的注解 ,[[元注解]]</li>
</ol>
<h1>Static</h1>
<blockquote>
<p>静态存放在堆内存中的静态域中</p>
</blockquote>
<h2 id="静态变量">静态变量</h2>
<ul>
<li>对象共享静态域</li>
</ul>
<h2 id="静态方法">静态方法</h2>
<h3 id="经典使用场景">经典使用场景</h3>
<p>当方法中不涉及到任何和对象相关的成员, 则可以将该方法设计成静态方法, 提高开发效率</p>
<ul>
<li>工具类中的方法 <code>utils</code>都是静态方法</li>
</ul>
<h3 id="使用细节">使用细节</h3>
<ol>
<li>类方法和普通方法都是随着类的加载而加载, 将结构信息存储在方法区:
<ol>
<li><mark style="background: #FF5582A6;">类方法中无this参数</mark></li>
<li>普通方法中隐含着this的参数</li>
</ol>
</li>
<li>类方法可以通过类名调用,也可通过对象名调用</li>
<li>普通方法和对象有关, 需要通过对象名调用</li>
<li>类方法中不可以出现和对象有关的关键字: <code>this</code> 和 <code>super</code></li>
<li><mark style="background: #FF5582A6;">静态方法只能调用静态成员或静态方法, 普通方法可以调用静态成员和非静态成员</mark></li>
</ol>
<hr>
<h3 id="思考">思考</h3>
<p><mark style="background: #FF5582A6;">static 相当于类本身的属性和方法.</mark></p>
<hr>
<h1>Object类</h1>
<h1>equals</h1>
<h2 id="equals-与-的比较">equals 与 == 的比较</h2>
<ul>
<li>==
<ul>
<li><mark style="background: #BBFABBA6;">是一个比较运算法</mark></li>
<li>既可以判断基本类型, 又可以判断引用类型</li>
<li>如果判断<strong>基本类型</strong>, 判断的是值是否相等.</li>
<li>如果判断<strong>引用类型</strong>, 判断的是地址是否相等
<ul>
<li>即判定是不是同一个对象</li>
</ul>
</li>
</ul>
</li>
<li>equals
<ul>
<li>Object类的一个方法, 只能判断引用类型</li>
<li>默认判断<strong>地址是否相等</strong>
<ul>
<li>子类往往重写该方法, 用于判读啊内容是否相等.
<ul>
<li>String 和 integer 的<code>equals</code> 都重写了,令其判断值是否相等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>hashCode</h1>
<ol>
<li>提高具有哈希结构的容器的效率</li>
<li>两个引用, 如果指向的是同一个对象, 则哈希值肯定一样的!</li>
<li>两个引用, 如果指向的是不同对象, 则哈希值是不一样的!</li>
<li>哈希值主要根据地址号来生成的!  不能完全将哈希值等价于地址.</li>
<li>后面在集合, 中hash code如果需要的话, 也会改写</li>
</ol>
<h1>toString</h1>
<blockquote>
<p>默认输出包名.类名@十六进制哈希值</p>
</blockquote>
<pre><code class="language-java">public String toString() &#123;  
    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());  
&#125;
</code></pre>
<ul>
<li>getClass().getName()
<ul>
<li>类的全类名</li>
</ul>
</li>
<li>Integer.toHexString(hashCode())
<ul>
<li>将对象的哈希值转化为十六进制</li>
</ul>
</li>
</ul>
<h1>finaliza</h1>
<ol>
<li>当对象被回收时,系统自动调用该对象的finalize方法. 子类可以重写该方法, 做一些释放资源的操作
<ol>
<li>什么时候被回收: 当莫个对象没有任何引用时, 则jvm就认为这个对象是一个垃圾对象, 就会使用垃圾回收机制来销毁该对象, 在销毁该对象前, 会先调用finalize方法.</li>
</ol>
</li>
<li>垃圾回收机制的调用,是由系统来决定的, <mark style="background: #ADCCFFA6;">也可以通过System.gc() 主动出发垃圾回收机制.</mark></li>
</ol>
<hr>
<p><mark style="background: #FF5582A6;">在实际开发中<code>finalize</code>方法已经弃用</mark></p>
<hr>
<h1>final</h1>
<blockquote>
<p>final可以修饰类 属性 方法 局部变量<br>
<mark style="background: #ADCCFFA6;">final中文意思: 最终的,最后的</mark></p>
</blockquote>
<h2 id="需要final的场景">需要final的场景</h2>
<ol>
<li>当不希望类被继承时, 可以用final</li>
<li>当不希望父类的某个方法被子类重写时</li>
<li>当不希望类的某个属性的值被修改, 可以用final</li>
<li>当不希望某个局部变量被修改时</li>
</ol>
<h2 id="使用细节-2">使用细节</h2>
<ol>
<li>final修饰的属性 又称 常量</li>
<li>常量在定义时必须 <strong>覆初值</strong> , 赋初值的位置如下
<ol>
<li>定义时</li>
<li>在构造器中</li>
<li>在代码块中</li>
</ol>
</li>
<li>final 在被 static 修饰时, 只能在
<ol>
<li>定义时</li>
<li>在静态代码块中
<ol>
<li><mark style="background: #FF5582A6;">不能在构造器中赋值</mark></li>
</ol>
</li>
</ol>
</li>
<li>final类不能被继承</li>
<li>如果类不是final类, 但含有final方法, 则该类无法重写, 但<mark style="background: #ADCCFFA6;">可以被继承</mark></li>
<li>一般如果一个类已经是final类, 就没有必要再将方法修饰为final方法</li>
<li>final不呢个修饰构造器</li>
<li><mark style="background: #D2B3FFA6;">fianl 和 static 往往搭配使用, 效率更高, 底层编译器做了优化处理</mark></li>
<li><mark style="background: #BBFABBA6;">包装类(integer Double Float Boolean 都是final), String也是final类</mark></li>
<li><mark style="background: #FF5582A6;">基本类型看值, 引用类型看地址, 数组是引用类型, 地址中的值可以被改变;</mark></li>
</ol>
<pre><code class="language-java">public class final01 &#123;  
    public final int TAX_RATE = 1;  
    public final int TAX_RATE2;  
    public final int TAX_RATE3;  
  
    public final01() &#123;  
        this.TAX_RATE2 = 2;  
    &#125;  
  
    &#123;        TAX_RATE3 = 3;  
    &#125;  
&#125;
</code></pre>

            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E7%AC%94%E8%AE%B0/" style="color: #03a9f4">笔记</a>
        </span>
        
    </div>
    <a href="/p/fd8e9709.html" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/p/6743bcc2.html">
        <h2 class="post-title">关于前端布局的一些知识</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/22
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>这篇笔记将简单介绍一下前端布局，包括其优缺点，以及其大致的应用场景。布局的选择在页面主体结构开发中至关重要，选择合适的布局模式，在开发过程中，会和德芙一样，纵享丝滑～</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E7%AC%94%E8%AE%B0/" style="color: #03a9f4">笔记</a>
        </span>
        
        <span class="tag">
            
            <a href="/tags/%E5%89%8D%E7%AB%AF/" style="color: #00a596">前端</a>
        </span>
        
    </div>
    <a href="/p/6743bcc2.html" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/p/2f57a694.html">
        <h2 class="post-title">正则表达式</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/8
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="什么是正则表达式">什么是正则表达式 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<p>正则表达式是一种用于匹配和处理文本的强大工具。它们可以用来验证输入，提取信息，替换文本，或者执行复杂的操作。在本文中，我们将介绍正则表达式的基本概念和语法，以及如何在不同的编程语言和工具中使用它们。</p>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E7%AC%94%E8%AE%B0/" style="color: #00bcd4">笔记</a>
        </span>
        
    </div>
    <a href="/p/2f57a694.html" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/p/63534.html">
        <h2 class="post-title">test</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/4/4
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h1>以下是测试部分</h1>
            
        </div>
    </div>
    <div class="post-tags">
        
        <span class="icon">
            <i class="fa-solid fa-tags fa-fw"></i>
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/%E7%AC%94%E8%AE%B0/" style="color: #00bcd4">笔记</a>
        </span>
        
    </div>
    <a href="/p/63534.html" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    <div class="prev">
        
    </div>
    <div class="page-index">
        
        <span class="current">1</span>
        
    </div>
    <div class="next">
        
    </div>
</div>

    </div>
    
    <div id="home-card">
        <div id="card-div">
    <div class="card-style">
        <div class="avatar">
            <img src="/images/shuibingyue.jpg" alt="avatar" />
        </div>
        <div class="name">ByL</div>
        <div class="description">
            <p>here’s a Description<br>
…</p>

        </div>
        
        <div class="icon-links">
            
        </div>
        
        
        <div class="friend-links">
            
            <div class="friend-link">
                <a target="_blank" rel="noopener" href="https://argvchs.netlify.app">Argvchs</a>
            </div>
            
        </div>
        
    </div>
</div>

    </div>
    
</div>

                    <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 ByL的小窝
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;ByL
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

                </div>
            </transition>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
    </body>
</html>
